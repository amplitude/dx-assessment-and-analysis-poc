import { ExperimentModel, VariantModel } from './models';
import { DuplicateNameMappingDetector } from "../../generators/DuplicateNameMappingDetector";
import { TypeScriptCodeLanguage } from "../../generators/typescript/TypeScriptCodeModel";
import { CodeBlock, CodeBlockTag } from "../../generators/code-generator";
import { ExperimentsConfig } from "../../generators/typescript/experiment";
import { CodeGenerationSettings } from "../../config";

export class ExperimentCodeGenerator {
  constructor(
    private lang: TypeScriptCodeLanguage = new TypeScriptCodeLanguage()
  ) {}

  generateExperimentType(experiment: ExperimentModel): string {
    const { getClassName, getPropertyName, getPropertyType } = this.lang;
    const className = getClassName(experiment.name);

    return `\
export type ${className} = {
  key: '${experiment.key}';
  name: "${experiment.name}";
${experiment.variants.map(
      v => `\
  ${getPropertyName(v.key)}: {
    key: '${v.key}',
    payload: ${getPropertyType(v.payload)}
  };`,
    ).join('\n')}
};`;
  }

  generateExperimentClass(experiment: ExperimentModel): string {
    const { getClassName, getPropertyName, getPropertyType } = this.lang;

    const className = getClassName(experiment.name);
    const getVariantTypeName = (v: VariantModel) => `${getClassName(v.key)}`;

    return `\
/* ${experiment.name} */
export namespace ${className}Variants {
${experiment.variants.map(v => `\
  export type ${getVariantTypeName(v)} = { key: '${v.key}', payload: ${getPropertyType(v.payload)} };`).join('\n')}

  export enum Keys {
${experiment.variants.map(v => `\
    ${getVariantTypeName(v)} = '${v.key}'`).join(',\n')}
  }
}
export type ${className}Type = BaseExperiment & {
${experiment.variants.map(v => `\
  ${getPropertyName(v.key)}?: ${className}Variants.${getVariantTypeName(v)};`).join('\n')}
}
export class ${className} implements ${className}Type {
  key = '${experiment.key}';
  name = "${experiment.name}";
  variant: ${experiment.variants.map(v => `\
${className}Variants.${getVariantTypeName(v)}`).join(' |')} | undefined;

  constructor(
${experiment.variants.map(v => `\
    public ${getPropertyName(v.key)}?: ${className}Variants.${getVariantTypeName(v)},`).join('\n')}
  ) {}
}
export namespace ${className} {
  export const Key = '${experiment.key}';
  export const Name = "${experiment.name}";

  export enum Variants {
${experiment.variants.map(v => `\
    ${getClassName(v.key)} = '${v.key}'`).join(',\n')}
  }
}`;
  }

  generateExperimentMethod(experiment: ExperimentModel): string {
    const { getClassName, getMethodName } = this.lang;

    const className = getClassName(experiment.name);
    const methodName = getMethodName(experiment.name);

    return `\
  ${methodName}(): ${className} {
    return core.getTypedVariant(new ${className}());
  }`;
  }

  generateAutogenHeader(): string {
    return `\
/* tslint:disable */
/* eslint-disable */
/**
 * Xpmt - A strong typed wrapper for your Experiment
 *
 * This file is generated by Amplitude.
 * To update run 'ampli exp -t token -d deployment-key'
 *
 * Required dependencies: @amplitude/experiment-js-client
 * Experiment Plan Version: 0
 * Build: 1.0.0
 * Runtime: browser:typescript
 */`;
  }

  generateXpntWrapper(
    experimentsConfig: ExperimentsConfig,
    codegenConfig: CodeGenerationSettings
  ): CodeBlock {
    const { tab, getMethodName, getClassName } = this.lang;
    // detect duplicate names
    // since the name mapping might map previously non-conflicting names to the same value (camelCase, etc)
    const duplicateDector = new DuplicateNameMappingDetector(getMethodName);
    const filteredExperiments = experimentsConfig.getExperiments().filter(e => {
      if (duplicateDector.hasDuplicateNameMapping(e.name)) {
        console.log(`Experiment "${e.name}" has a duplicate name mapping as another  and will be removed.`); // eslint-disable-line no-console
        return false;
      }
      return true;
    });

    return CodeBlock.from(
      CodeBlockTag.Import,
      `import { IExperimentClient as IExperimentClientCore } from "@amplitude/experiment-core";`,
    ).add(`\
export type BaseExperiment = {
  key: string;
  name: string;
}

${filteredExperiments.map(e => this.generateExperimentClass(e)).join('\n\n')}
export interface VariantMethods {
${filteredExperiments.map(e => `  ${getMethodName(e.name)}(): ${getClassName(e.name)};`).join('\n')}
}

export interface IExperimentClient extends IExperimentClientCore, Typed<VariantMethods> {}
    
export class Experiment extends ExperimentBrowser implements IExperimentClient {
  private getTypedVariant<T extends BaseExperiment>(exp: T) {
    const variant = this.variant(exp.key);
    if (typeof variant === 'string') {
        // FIXME: how to handle string responses?
        // (exp as any)[variant.value] = { payload: variant.payload };
        // (exp as any)['variant'] = { key: variant.value, payload: variant.payload };
    } else {
      if (variant.value) {
        (exp as any)[variant.value] = { payload: variant.payload };
        (exp as any)['variant'] = { key: variant.value, payload: variant.payload };
      }
    }
    return exp;
  }

  get ${codegenConfig.getTypedAnchorName()}() {
    const core = this;
    return {
${filteredExperiments.map(e => tab(2, this.generateExperimentMethod(e))).join(',\n')}
    };
  }
}

export const experiment = new Experiment();
export const typedExperiment = experiment.${codegenConfig.getTypedAnchorName()};
`);
  }
}
