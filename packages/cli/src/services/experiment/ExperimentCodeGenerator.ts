import { ExperimentModel, VariantModel } from './models';
import { DuplicateNameMappingDetector } from "../../generators/DuplicateNameMappingDetector";
import { TypeScriptCodeLanguage } from "../../generators/typescript/TypeScriptCodeModel";

function getVariantPayloadType(variant: VariantModel) {
  return getType(variant.payload);
}

function getType(obj: any): string {
  const type = typeof obj;
  if (['string', 'number', 'boolean', 'null'].includes(typeof obj)) {
    return type;
  }
  if (Array.isArray(obj)) {
    const itemType = (obj.length > 0) ? getType(obj[0]) : 'any';

    return `${itemType}[]`;
  }

  return 'any';
}

export class ExperimentCodeGenerator {
  constructor(
    private lang: TypeScriptCodeLanguage = new TypeScriptCodeLanguage()
  ) {}

  generateExperimentType(experiment: ExperimentModel): string {
    const { getClassName, getPropertyName } = this.lang;
    const className = getClassName(experiment.name);

    return `\
export type ${className} = {
  key: '${experiment.key}';
  name: "${experiment.name}";
${experiment.variants.map(
      v => `\
  ${getPropertyName(v.key)}: {
    key: '${v.key}',
    payload: ${getVariantPayloadType(v)}
  };`,
    ).join('\n')}
};`;
  }

  generateExperimentClass(experiment: ExperimentModel): string {
    const { getClassName, getPropertyName } = this.lang;
    const className = getClassName(experiment.name);
    const getVariantTypeName = (v: VariantModel) => `${className}${getClassName(v.key)}`;

    return `\
${experiment.variants.map(v => `\
export type ${getVariantTypeName(v)} = { key: '${v.key}', payload: ${getVariantPayloadType(v)} };`).join('\n')}
export type ${className}Variants = BaseExperiment & {
${experiment.variants.map(v => `\
  ${getPropertyName(v.key)}?: ${getVariantTypeName(v)};`).join('\n')}
}
export class ${className} implements ${className}Variants {
  key = '${experiment.key}';
  name = "${experiment.name}";
  constructor(
${experiment.variants.map(v => `\
    public ${getPropertyName(v.key)}?: ${getVariantTypeName(v)},`).join('\n')}
  ) {}
}`;
  }

  generateExperimentClass2(experiment: ExperimentModel): string {
    const { getClassName, getPropertyName } = this.lang;

    const className = getClassName(experiment.name);
    const getVariantTypeName = (v: VariantModel) => `${getClassName(v.key)}`;

    return `\
/* ${experiment.name} */
export namespace ${className}Variants {
${experiment.variants.map(v => `\
  export type ${getVariantTypeName(v)} = { key: '${v.key}', payload: ${getVariantPayloadType(v)} };`).join('\n')}
  export enum Keys {
${experiment.variants.map(v => `\
    ${getVariantTypeName(v)} = '${v.key}'`).join(',\n')}
  }
}
export type ${className}Type = BaseExperiment & {
${experiment.variants.map(v => `\
  ${getPropertyName(v.key)}?: ${className}Variants.${getVariantTypeName(v)};`).join('\n')}
}
export class ${className} implements ${className}Type {
  key = '${experiment.key}';
  name = "${experiment.name}";
  variant: ${experiment.variants.map(v => `\
${className}Variants.${getVariantTypeName(v)}`).join(' |')} | undefined;
  constructor(
${experiment.variants.map(v => `\
    public ${getPropertyName(v.key)}?: ${className}Variants.${getVariantTypeName(v)},`).join('\n')}
  ) {}
}
export namespace ${className} {
  export const Key = '${experiment.key}';
  export const Name = "${experiment.name}";
  export enum Variants {
${experiment.variants.map(v => `\
    ${getClassName(v.key)} = '${v.key}'`).join(',\n')}
  }
}`;
  }

  generateExperimentMethod(experiment: ExperimentModel): string {
    const { getClassName, getMethodName } = this.lang;

    const className = getClassName(experiment.name);
    const methodName = getMethodName(experiment.name);

    return `\
  public ${methodName}(): ${className} {
    return this.getVariantAndTranslate<${className}>('${experiment.key}');
  }`;
  }

  generateExperimentMethod2(experiment: ExperimentModel): string {
    const { getClassName, getMethodName } = this.lang;

    const className = getClassName(experiment.name);
    const methodName = getMethodName(experiment.name);

    return `\
  public ${methodName}(): ${className} {
    return this.getTypedVariant(new ${className}());
  }`;
  }

  generateAutogenHeader(): string {
    return `\
/* tslint:disable */
/* eslint-disable */
/**
 * Xpmt - A strong typed wrapper for your Experiment
 *
 * This file is generated by Amplitude.
 * To update run 'ampli exp -t token -d deployment-key'
 *
 * Required dependencies: @amplitude/experiment-js-client
 * Experiment Plan Version: 0
 * Build: 1.0.0
 * Runtime: browser:typescript
 */`;
  }

  generateXpntWrapper(experiments: ExperimentModel[]): string {
    // detect duplicate names
    // since the name mapping might map previously non-conflicting names to the same value (camelCase, etc)
    const duplicateDector = new DuplicateNameMappingDetector(this.lang.getMethodName);
    const filteredExperiments = experiments.filter(e => {
      if (duplicateDector.hasDuplicateNameMapping(e.name)) {
        console.log(`Experiment "${e.name}" has a duplicate name mapping as another  and will be removed.`); // eslint-disable-line no-console
        return false;
      }
      return true;
    });

    return `\
export type BaseExperiment = {
  key: string;
  name: string;
}
${filteredExperiments.map(e => this.generateExperimentClass2(e)).join('\n\n')}
export class Xpmt {
  /**
   * Initialize experiment.
   *
   * @param apiKey Experiment deployment key.
   * @param config Experiment client configuration.
   */
  public static initialize(apiKey: string, config?: ExperimentConfig): Xpmt {
    const client = Experiment.initialize(apiKey, config);
    return new Xpmt(client);
  }
  /**
   * The underlying experiment client.
   */
  public readonly client: ExperimentClient;
  /**
   * Fetch variants for a user.
   *
   * This user is merged with the user provided by the client's user provider.
   *
   * @param user The user to fetch variants for.
   */
  public async fetch(user?: ExperimentUser): Promise<Xpmt> {
    await this.client.fetch(user)
    return this;
  }
  private constructor(client: ExperimentClient) {
    this.client = client;
  }
  private getTypedVariant<T extends BaseExperiment>(exp: T) {
    const variant = this.client.variant(exp.key);
    if (variant.value) {
      (exp as any)[variant.value] = { payload: variant.payload };
      (exp as any)['variant'] = { key: variant.value, payload: variant.payload };
    }
    return exp;
  }
${filteredExperiments.map(e => this.generateExperimentMethod2(e)).join('\n\n')}
}
`;
  }
}
